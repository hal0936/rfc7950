5.5.  Nested Typedefs and Groupings

      嵌套的Typedef和Groupings

   Typedefs and groupings may appear nested under many YANG statements,
   allowing these to be lexically scoped by the statement hierarchy
   under which they appear.  This allows types and groupings to be
   defined near where they are used, rather than placing them at the
   top level of the hierarchy.  The close proximity increases
   readability.

   typedef和grouping可能在许多模块中以嵌套的方式出现，它们出现层级结构的声明之下，
   这种层级结构的声明允许这种词法允许的范围。type和group应该的定义靠近它们被使用的地方，
   而不是在分层的顶层处。靠近的使用可以增加可读性。

   Scoping also allows types to be defined without concern for naming
   conflicts between types in different submodules.  Type names can be
   specified without adding leading strings designed to prevent name
   collisions within large modules.

   词法范围允许定义type时不关心不同子模块之间的命名冲突。在一个大模块里指定type名称时，
   不需要设计一个附加的前导字符串去防止命名冲突。

   Finally, scoping allows the module author to keep types and groupings
   private to their module or submodule, preventing their reuse.  Since
   only top-level types and groupings (i.e., those appearing as
   substatements to a "module" or "submodule" statement) can be used
   outside the module or submodule, the developer has more control over
   what pieces of their module are presented to the outside world,
   supporting the need to hide internal information and maintaining a
   boundary between what is shared with the outside world and what is
   kept private.

   最后，词法允许模块作者在他们的模块或者子模块中将type和group保持为私有，
   以防止被复用。因为只有顶层类型和组(例如，以一个模块或者子模块声明的子声明形式出现)
   可以在模块或者子模块外部被使用，开发者们能更好地控制模块哪些部分暴露给外部，
   支持隐藏内部信息的需求并且维护一个外部共享和内部维护的界限，

   Scoped definitions MUST NOT shadow definitions at a higher scope.  A
   type or grouping cannot be defined if a higher level in the statement
   hierarchy has a definition with a matching identifier.

   域内的定义不能对更高层的域隐藏它的定义。在分级的声明中，如果一个定义被更高的等级
   定义了，它将不能再被定义。

   A reference to an unprefixed type or grouping, or one that uses the
   prefix of the current module, is resolved by locating the matching
   "typedef" or "grouping" statement among the immediate substatements
   of each ancestor statement.

   引用一个不带前缀的类型或者组，或者使用本模块的前缀，会被定位到距离最近的
   "typedef"或者"grouping"原始声明。
